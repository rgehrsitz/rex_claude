package bytecode

import (
	"encoding/json"
	"rgehrsitz/rex/internal/rules"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCompileSimpleRule(t *testing.T) {
	// Define the JSON for the simple rule
	ruleJSON := `[
        {
            "name": "SimpleRule",
            "conditions": {
                "all": [
                    {
                        "fact": "temperature",
                        "operator": "greaterThan",
                        "value": 30,
                        "valueType": "int"
                    }
                ],
                "any": []
            },
            "event": {
                "actions": [
                    {
                        "type": "updateFact",
                        "target": "ac_status",
                        "value": true
                    }
                ]
            },
            "producedFacts": ["ac_status"],
            "consumedFacts": ["temperature"]
        }
    ]`

	// Parse the rule JSON
	var ruleset []*rules.Rule
	err := json.Unmarshal([]byte(ruleJSON), &ruleset)
	require.NoError(t, err, "Failed to parse rule JSON")

	// Initialize the RuleEngineContext
	context := rules.NewRuleEngineContext()

	// Create the compiler instance
	compiler := NewCompiler(context)

	// After parsing the rules into validatedRules and before compiling:
	for _, rule := range ruleset {
		for _, fact := range rule.ConsumedFacts {
			if _, exists := context.FactIndex[fact]; !exists {
				context.FactIndex[fact] = len(context.FactIndex) // Assign a new index
			}
		}
		for _, fact := range rule.ProducedFacts {
			if _, exists := context.FactIndex[fact]; !exists {
				context.FactIndex[fact] = len(context.FactIndex) // Assign a new index
			}
		}
	}

	// Compile the ruleset
	bytecode, err := compiler.Compile(ruleset)
	require.NoError(t, err, "Compilation failed")

	// Assert that the bytecode is not nil or empty
	assert.NotEmpty(t, bytecode, "Compiled bytecode should not be empty")

	// Detailed bytecode assertion
	expectedBytecode := []byte{
		17, 0, // LOAD_FACT "temperature"
		19, 30, 0, 0, 0, // LOAD_CONST_INT 30
		4,        // GT_INT
		0, 15, 0, // JUMP_IF_FALSE 15 (little-endian byte order)
		28, 1, // UPDATE_FACT "ac_status"
		22, 1, // LOAD_CONST_BOOL true
	}
	assert.Equal(t, expectedBytecode, bytecode, "The generated bytecode does not match the expected sequence")

}
