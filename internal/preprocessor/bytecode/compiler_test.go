package bytecode

import (
	"bytes"
	"encoding/binary"
	"hash/crc32"
	"rgehrsitz/rex/internal/rules"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCompilerSimpleRule(t *testing.T) {
	// Define the test case
	rule := &rules.Rule{
		Name: "SimpleRule",
		Conditions: rules.Conditions{
			All: []rules.Condition{
				{
					Fact:      "temperature",
					Operator:  "greaterThan",
					Value:     30,
					ValueType: "int",
				},
			},
			Any: []rules.Condition{},
		},
		Event: rules.Event{
			Actions: []rules.Action{
				{
					Type:   "updateFact",
					Target: "ac_status",
					Value:  true,
				},
			},
		},
		ProducedFacts: []string{"ac_status"},
		ConsumedFacts: []string{"temperature"},
	}

	// Initialize a new RuleEngineContext
	context := rules.NewRuleEngineContext()

	// Create a new instance of the compiler
	compiler := NewCompiler(context)

	// Compile the rule
	bytecode, err := compiler.Compile([]*rules.Rule{rule})
	require.NoError(t, err, "Compilation failed")

	// Define the expected bytecode instructions and operands
	expectedBytecodeInstructions := []byte{
		byte(LABEL),                                                               // LABEL rule_SimpleRule_start
		byte(LOAD_FACT), 't', 'e', 'm', 'p', 'e', 'r', 'a', 't', 'u', 'r', 'e', 0, // LOAD_FACT temperature
		byte(LOAD_CONST_INT), 30, 0, 0, 0, // LOAD_CONST_INT 30
		byte(GT_INT),                                                                                                          // GT_INT
		byte(JUMP_IF_FALSE), 'r', 'u', 'l', 'e', '_', 'S', 'i', 'm', 'p', 'l', 'e', 'R', 'u', 'l', 'e', '_', 'e', 'n', 'd', 0, // JUMP_IF_FALSE rule_SimpleRule_end
		byte(UPDATE_FACT), 'a', 'c', '_', 's', 't', 'a', 't', 'u', 's', 0, // UPDATE_FACT ac_status
		byte(LOAD_CONST_BOOL), 1, // LOAD_CONST_BOOL true
		byte(LABEL), // LABEL rule_SimpleRule_end
	}

	// Calculate the bytecode size
	bytecodeSize := len(bytecode)

	// Create the expected bytecode with the header
	expectedBytecode := []byte{
		1, 0, // Version
		0, 0, 0, 0, // Checksum (placeholder)
		1, 0, // Number of rules
		byte(bytecodeSize), byte(bytecodeSize >> 8), 0, 0, // Bytecode size (little-endian)
	}
	expectedBytecode = append(expectedBytecode, expectedBytecodeInstructions...)

	// Create a byte buffer and write the expected bytecode (excluding the checksum)
	var buf bytes.Buffer
	buf.Write(expectedBytecode[:2]) // Write version
	buf.Write(expectedBytecode[6:]) // Write bytecode (excluding checksum)

	// Calculate the checksum of the buffer
	checksum := crc32.ChecksumIEEE(buf.Bytes())

	// Update the checksum in the expected bytecode
	binary.LittleEndian.PutUint32(expectedBytecode[2:6], checksum)

	// Compare the generated bytecode with the expected bytecode
	assert.Equal(t, expectedBytecode, bytecode, "Generated bytecode does not match expected bytecode")
}
